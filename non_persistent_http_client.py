from socket import *
from multiprocessing import Pool
from bs4 import BeautifulSoup
import statistics as st
import threading
import select
import random
import time
import os


"""
Note: Instead of Closing the connection each time, Non-Persistent can also be implemented by specifying the following Connection Header:

connection_header = "Connection: close"
request = method + index_character + protocol + version + separator + host_parameter + separator + connection_header + termination_character

If above 2 lines are implemented, all socket.close() can be removed with standard Python HTTP Server.
"""




# Defining Global Parameters
SERVER_IP = "173.230.149.18"
# SERVER_IP = "127.0.0.1"
SERVER_PORT = 23662
REQUEST_HOST = "{}:{}".format(SERVER_IP, SERVER_PORT)
INDEX = " / "


# Performance based Parameters
# Total delay to complete all steps or TOTAL_PLT
TOTAL_DELAY = 0
ABOVE_THE_FOLD_PLT = 0
REQUEST_DELAYS = []
BACKOFF_FACTOR = 1



downloaded_images_directory = "./images/"
if not os.path.exists(downloaded_images_directory):
	os.makedirs(downloaded_images_directory)



class SocketData:

	def __init__(self, SERVER_IP, SERVER_PORT):
		self.socket = socket(AF_INET, SOCK_STREAM)
		self.socket.connect((SERVER_IP, SERVER_PORT))
		# self.socket.setblocking(0)

	def send_request(self, host_address, index):
		'''
		Func: Input   : URL to send the request to
			  Returns : HTTP Request (Example: "GET / HTTP/1.1\r\nHost: www.cnn.com\r\n\r\n")
		'''
		separator = "\r\n"
		method = "GET"
		index_character = index
		protocol = "HTTP"
		version = "/1.1"
		host_parameter = "Host: {}".format(host_address)
		x_client_project = "X-Client-project: project-152A-part2"
		# host_delay = "Host-delay: {}".format(SERVER_DELAY)
		termination_character = "\r\n\r\n"
		request = method + index_character + protocol + version + separator + host_parameter + separator + x_client_project + termination_character
		# print("Request Message: \"{}\" sent.".format(request))
		self.socket.sendall(request.encode())		

	def receive_response(self):
		'''
		Func: Input   : Uses Current Socket Object
			  Returns : HTTP Response from server generated by combining all the TCP Segments
		'''
		message, chunk_size, size = b'', 0, 10000000

		while chunk_size < size:
			try:
				chunk = self.socket.recv(4096)

				if not(chunk):
					break
				message += chunk
				chunk_size += len(chunk)
				
				if size == 10000000:
					# print(chunk)
					for header_name in chunk.split(b"\r\n"):
						if (b"Content-Length: " in header_name) or (b"Content-length: " in header_name):
							size = int(header_name.replace(b"Content-length: ",b"").replace(b"Content-Length: ",b"").decode())
							print(size)	
			except BaseException as e: 
				#ConnectionResetError
				# print(e)
				pass
		return message

	def parse_response_html(self, html):
		'''
		Func: Input   : HTML Response obtained from Server
			  Returns : src attribute of all the images
		'''
		image_sources = []
		soup = BeautifulSoup(html, 'html.parser')
		images = soup.findAll('img')

		for image in images:
			image_sources.append(image['src'])

		return image_sources

	def save_response_as_html_file(self, html):
		'''
		Func: Input   : HTML Response obtained from Server
			  Returns : None
		'''
		pos = html.find(b"\r\n\r\n")
		html = html[pos+4:]
		html_file = open("ecs152a.html","wb")
		html_file.write(html)
		html_file.close()

	def close(self):
		'''
		Func: Closing the socket
		'''
		# self.socket.shutdown(1)
		self.socket.close()
		




def get_size_of_string_in_bytes(s):
	return len(s.encode('utf-8'))



def generate_and_download_image_from_response(response, img_filepath):
	'''
	Func: Input   : Response object in bytes
		  Returns : Extracts the image from response and saves it in images directory
	'''
	# Computing response header part
	pos = response.find(b"\r\n\r\n")
	# print(response[:pos].decode('utf-8'))

	# Skipping response header part and saving the image data
	response = response[pos+4:]
	img = open(img_filepath, 'wb')
	img.write(response)
	img.close()



def fetch_server_images(image_sources):
	'''
	Func: Input   : src attributes of images
		  Returns : None; fetches images hosted on same as well as external server
	'''
	external_index_mapping = {"http://web.mit.edu/torralba/www/allIndoors.jpg": " /torralba/www/allIndoors.jpg ",
				  "http://places2.csail.mit.edu/imgs/demo/7.jpg": " /imgs/demo/7.jpg ",
				  "http://humaneva.is.tue.mpg.de/assets/GUI_Screenshot.jpg": " /assets/GUI_Screenshot.jpg ",
				  "http://labelme2.csail.mit.edu/Release3.0/browserTools/icons/labeling.jpg": " /Release3.0/browserTools/icons/labeling.jpg "}
	
	global TOTAL_DELAY, ABOVE_THE_FOLD_PLT;

	for source in image_sources:
		start, end = 0, 0
		# print(source)
		
		if source.startswith("images/"):\
			# Fetching Same Server Images
			INDEX = " /" + source + " "
			start = time.time()
			sdata1 = SocketData(SERVER_IP, SERVER_PORT)
			sdata1.send_request(REQUEST_HOST, INDEX)
			http_resp = sdata1.receive_response()
			end = time.time()
			filepath = downloaded_images_directory + INDEX.replace("/images/","")
			generate_and_download_image_from_response(http_resp, filepath)
			sdata1.close()
			time_elapsed = (end - start)
			TOTAL_DELAY += time_elapsed
			REQUEST_DELAYS.append(time_elapsed)
		else:
			# Fetching External Server Images
			INDEX = external_index_mapping[source]
			host_name = source.split("/")[2]
			start = time.time()
			sdata2 = SocketData(host_name, 80)
			sdata2.send_request(host_name, INDEX)
			response = sdata2.receive_response()
			end = time.time()
			filepath = downloaded_images_directory + INDEX.strip().split("/")[-1]
			generate_and_download_image_from_response(response, filepath)
			sdata2.close()
			time_elapsed = (end - start)
			TOTAL_DELAY += time_elapsed
			REQUEST_DELAYS.append(time_elapsed)

			if "http://web.mit.edu/" in source:
				# print("MIT", time_elapsed)
				ABOVE_THE_FOLD_PLT += time_elapsed



def print_performance_stats():
	'''
	Func: Input   : Uses Globally defined performance variables
		  Returns : Prints Performance stats
	'''
	print("\n********************************************")
	print("\nHTTP Client Version: Non-Persistent HTTP")
	print("\nTotal PLT = {}".format(TOTAL_DELAY))
	print("\nAverage Request Delay = {}".format(st.mean(REQUEST_DELAYS)))
	# print("\nPage Load Time = {}".format(TOTAL_DELAY))
	print("\nATF PLT = {}".format(ABOVE_THE_FOLD_PLT))
	print("\nRPS = {}".format(round((339/float(sum(REQUEST_DELAYS[:]))),2)))
	# print("\nRequest No. that took Maximum Time = {}".format(REQUEST_DELAYS.index(max(REQUEST_DELAYS)) + 1))
	print("\n********************************************")




def main():

	global TOTAL_DELAY, ABOVE_THE_FOLD_PLT, REQUEST_DELAYS;

	TOTAL_DELAY, ABOVE_THE_FOLD_PLT, start, end = 0, 0, 0, 0
	REQUEST_DELAYS = []

	# Fetching Images
	INDEX = " /ecs152a.html "
	start = time.time()
	sdata = SocketData(SERVER_IP, SERVER_PORT)
	sdata.send_request(REQUEST_HOST, INDEX)
	response = sdata.receive_response()
	end = time.time()
	sdata.save_response_as_html_file(response)
	# Parsing ecs152a.html
	image_indexes = sdata.parse_response_html(response)
	sdata.close()

	time_elapsed = (end - start)
	TOTAL_DELAY += time_elapsed
	ABOVE_THE_FOLD_PLT += time_elapsed
	REQUEST_DELAYS.append(time_elapsed)
	

	# Fetching Images
	external_requests = fetch_server_images(image_indexes)

	# Printing all the performance statistics
	print_performance_stats()
	# print(REQUEST_DELAYS)
	# print('Connection: {}, RPS: {}, Total PLT: {}, ATF PLT: {}'.format("Non-Persistent", round((339/float(sum(REQUEST_DELAYS[:]))),2), TOTAL_DELAY, ABOVE_THE_FOLD_PLT))




if __name__ == "__main__":
	main()


